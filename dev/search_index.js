var documenterSearchIndex = {"docs":
[{"location":"guides/levels/#Segmentation-Levels-inside-a-PreprocessBundle","page":"Levels","title":"Segmentation Levels inside a PreprocessBundle","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"A PreprocessBundle stores the same corpus at multiple segmentation levels so that any downstream component can choose the most convenient granularity:","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"byte  ->  character  ->  word  ->  sentence  ->  paragraph  ->  document","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"Each level is wrapped in a LevelBundle; all bundles live in the dictionary bundle.levels.","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"struct PreprocessBundle{ExtraT}\n    levels     :: Dict{Symbol,LevelBundle}             # the stack\n    metadata   :: PipelineMetadata                     # conf + schema\n    alignments :: Dict{Tuple{Symbol,Symbol},CrossMap}  # level-to-level\n    extras     :: ExtraT                               # user payload\nend","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"","category":"page"},{"location":"guides/levels/#Level-cheat-sheet","page":"Levels","title":"Level cheat-sheet","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"Level symbol Token example Offset vector inside Corpus\n:byte one UTF-8 byte byte_offsets\n:character Unicode scalar value character_offsets\n:word whitespace/unicode-split word word_offsets\n:sentence heuristic sentence span sentence_offsets\n:paragraph blank-line span paragraph_offsets\n:document whole source file document_offsets","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"Use the lookup table LEVEL_TO_OFFSETS_FIELD to get the field name programmatically:","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"field = LEVEL_TO_OFFSETS_FIELD[:sentence]   # :sentence_offsets\nspans = getfield(corpus, field)","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"","category":"page"},{"location":"guides/levels/#Creating-or-guaranteeing-levels","page":"Levels","title":"Creating or guaranteeing levels","text":"","category":"section"},{"location":"guides/levels/#Built-in-pipelines","page":"Levels","title":"Built-in pipelines","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"Pipeline call Levels you always get\npreprocess_corpus :byte, :character, :word (+ optional sentence/paragraph)\npreprocess_corpus_streaming* same per chunk; merge helper rebuilds alignments","category":"page"},{"location":"guides/levels/#Helper-functions","page":"Levels","title":"Helper functions","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"_ensure_lower_levels!(bundle)      # synthesise :character / :byte if missing\nbuild_alignments!(bundle)          # create cross-maps already available levels\nbuild_ensure_alignments!(bundle)   # do both, idempotent","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"","category":"page"},{"location":"guides/levels/#Quick-examples","page":"Levels","title":"Quick examples","text":"","category":"section"},{"location":"guides/levels/#Inspect-the-word-vocabulary","page":"Levels","title":"Inspect the word vocabulary","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"bund   = preprocess_corpus(\"books/*\")\nwvocab = bund.levels[:word].vocabulary\nprintln(\"vocab size = \", length(wvocab.id_to_token_strings))","category":"page"},{"location":"guides/levels/#Map-byte-123-to-its-word-index","page":"Levels","title":"Map byte 123 to its word index","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"build_ensure_alignments!(bund)            # guarantee maps exist\nword_idx = bund.alignments[(:byte,:word)].alignment[123]","category":"page"},{"location":"guides/levels/#Add-a-custom-feature-matrix-as-extras","page":"Levels","title":"Add a custom feature matrix as extras","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"feats = rand(Float32, length(get_token_ids(bund,:word)), 128)\nbund  = PreprocessBundle(bund.levels;\n                         metadata   = bund.metadata,\n                         alignments = bund.alignments,\n                         extras     = feats)","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"","category":"page"},{"location":"guides/levels/#Offset-vector-convention","page":"Levels","title":"Offset-vector convention","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"Every offset vector satisfies","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"issorted(vec) == true\nvec[1]        ∈ (0, 1)        # leading sentinel\nvec[end]      ≥ n_tokens      # trailing sentinel (n  or  n+1)","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"The streaming merge helper recognises both sentinel styles.","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"","category":"page"},{"location":"guides/levels/#Common-pitfalls","page":"Levels","title":"Common pitfalls","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"Pitfall Remedy\nMissing :byte / :character levels after custom manipulation Call build_ensure_alignments!(bundle) once more.\nAccessing an alignment that isn’t there → KeyError Check keys(bundle.alignments) or call build_alignments!.\nOffset validation failure when you inject your own Corpus Run validate_offsets(corpus, :level) before constructing LevelBundle.","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"","category":"page"},{"location":"guides/levels/#APIs-at-a-glance","page":"Levels","title":"APIs at a glance","text":"","category":"section"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"_ensure_lower_levels!(bundle::PreprocessBundle)          -> PreprocessBundle\nbuild_alignments!(bundle; pairs=[...])                   -> PreprocessBundle\nbuild_ensure_alignments!(bundle)                         -> PreprocessBundle\nLEVEL_TO_OFFSETS_FIELD::Dict{Symbol,Symbol}","category":"page"},{"location":"guides/levels/","page":"Levels","title":"Levels","text":"With these utilities your bundles are always multi-level, aligned, and self-describing.","category":"page"},{"location":"api/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/#KeemenaPreprocessing.TOKENIZERS","page":"API Reference","title":"KeemenaPreprocessing.TOKENIZERS","text":"TOKENIZERS\n\nA constant Tuple{Symbol} listing the names of built-in tokenizers that can be passed to the tokenizer_name keyword of PreprocessConfiguration.\n\nCurrently supported values are\n\n:whitespace - split on Unicode whitespace;\n:unicode    - iterate user-perceived graphemes (eachgrapheme);\n:byte       - treat the text as raw bytes (byte-level models);\n:char       - split on individual UTF-8 code units.\n\nYou may also supply any callable that implements mytokens = f(string) in place of one of these symbols.\n\n\n\n\n\n","category":"constant"},{"location":"api/#KeemenaPreprocessing.Corpus","page":"API Reference","title":"KeemenaPreprocessing.Corpus","text":"Corpus\n\nFlat, memory-efficient container that stores an entire corpus of token-ids together with optional hierarchical offset tables that recover the original structure (documents → paragraphs → sentences → words → characters → bytes).\n\nEvery offset vector records the starting index (1-based, inclusive) of each unit inside token_ids.  The final entry therefore equals length(token_ids)+1, making range retrieval convenient via view(token_ids, offsets[i] : offsets[i+1]-1).\n\nFields\n\nfield type always present? description\ntoken_ids Vector{Int} ✓ Concatenated token identifiers returned by the vocabulary.\ndocument_offsets Vector{Int} ✓ Start positions of each document (outermost level).\nparagraph_offsets Union{Vector{Int},Nothing} cfg-dependent Paragraph starts within each document when record_paragraph_offsets=true.\nsentence_offsets Union{Vector{Int},Nothing} cfg-dependent Sentence boundaries when record_sentence_offsets=true.\nword_offsets Union{Vector{Int},Nothing} cfg-dependent Word boundaries when record_word_offsets=true.\ncharacter_offsets Union{Vector{Int},Nothing} cfg-dependent Unicode-character spans when record_character_offsets=true.\nbyte_offsets Union{Vector{Int},Nothing} cfg-dependent Byte-level spans when record_byte_offsets=true.\n\nExample\n\n# assume `corp` is a Corpus produced by preprocess_corpus\ndoc1_range = corp.document_offsets[1] : corp.document_offsets[2]-1\ndoc1_token_ids = view(corp.token_ids, doc1_range)\n\nif corp.sentence_offsets ≠ nothing\n    first_sentence = view(corp.token_ids,\n                          corp.sentence_offsets[1] : corp.sentence_offsets[2]-1)\nend\n\nThe presence or absence of each optional offsets vector is determined entirely by the corresponding record_*_offsets flags in PreprocessConfiguration.\n\n\n\n\n\n","category":"type"},{"location":"api/#KeemenaPreprocessing.CrossMap","page":"API Reference","title":"KeemenaPreprocessing.CrossMap","text":"CrossMap\n\nAlignment table that links two segmentation levels of the same corpus (e.g. bytes -> characters, characters -> words, words -> sentences).\n\nFor every unit in the destination level the alignment vector stores the 1-based index into the source offsets at which that unit begins. This allows constant-time projection of any span expressed in destination units back to the finer-grained source sequence.\n\nFields\n\nsource_level      :: Symbol   Name of the finer level (must match a key in bundle.levels, typically :byte, :char, :word, :sentence, or :paragraph).\ndestination_level :: Symbol   Name of the coarser level whose boundaries are encoded.\nalignment         :: Vector{Int}   Length = N_destination + 1.   alignment[i] is the starting source-level offset of destination element i; the extra sentinel entry alignment[end] = N_source + 1 lets you slice with   alignment[i] : alignment[i+1]-1 without bounds checks.\n\nExample\n\n# map words ⇒ sentences\nm = CrossMap(:word, :sentence, sent2word_offsets)\n\nfirst_sentence_word_ids = alignment_view(m, 1)  # helper returning a view\n\nThe constructor is trivial and performs no validation; pipelines are expected to guarantee consistency when emitting CrossMap objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#KeemenaPreprocessing.CrossMap-Tuple{Symbol, Symbol, AbstractVector{<:Integer}}","page":"API Reference","title":"KeemenaPreprocessing.CrossMap","text":"CrossMap(src, dst, align)\n\nShorthand outer constructor that builds a CrossMap while materialising the alignment vector as Vector{Int}.\n\nArguments\n\nsrc::Symbol - identifier of the source (finer-grained) level   (e.g. :char, :word).\ndst::Symbol - identifier of the destination (coarser) level   (e.g. :word, :sentence).\nalign::AbstractVector{<:Integer} - offset array mapping every destination unit to its starting position in the source sequence.  Any integer-typed vector is accepted; it is copied into a dense Vector{Int} to guarantee contiguous storage and type stability inside the resulting CrossMap.\n\nReturns\n\nA CrossMap(src, dst, Vector{Int}(align)).\n\nExample\n\ncm = CrossMap(:char, :word, UInt32[1, 5, 9, 14])\n@assert cm.alignment isa Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.LevelBundle","page":"API Reference","title":"KeemenaPreprocessing.LevelBundle","text":"LevelBundle\n\nSelf-contained pairing of a Corpus and its companion Vocabulary.  A LevelBundle represents one segmentation level (e.g. words, characters, or bytes) produced by the preprocessing pipeline. By storing both objects side-by-side it guarantees that every token_id found in corpus.token_ids is valid according to vocabulary.\n\nFields\n\ncorpus     :: Corpus   All token-ids plus optional offset tables describing the structure of the text at this level.\nvocabulary :: Vocabulary   Bidirectional mapping between token strings and the integer ids used in corpus.token_ids.\n\nIntegrity checks\n\nThe inner constructor performs two runtime validations:\n\nRange check - the largest token-id must not exceed length(vocabulary.id_to_token_strings).\nLower bound - all token-ids must be >= 1 (id 0 is never legal).\n\nViolations raise an informative ArgumentError, catching mismatches early.\n\nExample\n\nword_corpus  = Corpus(word_ids, doc_offs, nothing, sent_offs, word_offs,\n                      nothing, nothing)\nword_vocab   = build_vocabulary(words; minimum_token_frequency = 2)\n\nword_bundle  = LevelBundle(word_corpus, word_vocab)\n\nnb_tokens    = length(word_bundle.vocabulary.id_to_token_strings)\n@info \"bundle contains nb_tokens unique tokens\"\n\n\n\n\n\n","category":"type"},{"location":"api/#KeemenaPreprocessing.PipelineMetadata","page":"API Reference","title":"KeemenaPreprocessing.PipelineMetadata","text":"PipelineMetadata\n\nCompact header bundled with every artefact produced by KeemenaPreprocessing. It records the exact pipeline settings and the version of the on-disk schema so that data can be re-processed, inspected, or migrated safely.\n\nFields\n\nconfiguration::PreprocessConfiguration   The full set of cleaning, tokenisation, vocabulary, and offset-recording options that generated the artefact.  Storing this ensures strict reproducibility.\nschema_version::VersionNumber   The version of the bundle file format (not the Julia package).   Increment the major component when breaking changes are introduced so that loaders can detect incompatibilities and perform migrations or raise errors.\n\nExample\n\ncfg  = PreprocessConfiguration(strip_html_tags = true)\nmeta = PipelineMetadata(cfg, v\"1.0.0\")\n\n@info \"tokeniser:\" meta.configuration.tokenizer_name\n@assert meta.schema_version >= v\"1.0.0\"\n\n\n\n\n\n","category":"type"},{"location":"api/#KeemenaPreprocessing.PipelineMetadata-Tuple{}","page":"API Reference","title":"KeemenaPreprocessing.PipelineMetadata","text":"PipelineMetadata() -> PipelineMetadata\n\nConvenience constructor that returns a metadata header with\n\nthe default PreprocessConfiguration() (all keyword-arguments left at their documented defaults); and\nthe current bundle schema version v\"1.0.0\".\n\nHandy for rapid prototyping or unit tests when you do not need to customise the pipeline but still require a valid PipelineMetadata object.\n\nIdentical to:\n\nPipelineMetadata(PreprocessConfiguration(), v\"1.0.0\")\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.PreprocessBundle","page":"API Reference","title":"KeemenaPreprocessing.PreprocessBundle","text":"PreprocessBundle{ExtraT}\n\nTop-level artefact emitted by preprocess_corpus (or the streaming variant). A bundle contains everything required to feed a downstream model or to reload a corpus without re-running the expensive preprocessing pipeline.\n\nType parameter\n\nExtraT - arbitrary payload for user-defined information (e.g. feature matrices, clustering assignments, language tags).  Use Nothing when no extras are needed.\n\nFields\n\nfield type description\nlevels Dict{Symbol,LevelBundle} Mapping from segmentation level name (:byte, :char, :word, :sentence, :paragraph, …) to the corresponding LevelBundle.\nmetadata PipelineMetadata Reproducibility header (configuration + schema version).\nalignments Dict{Tuple{Symbol,Symbol},CrossMap} Pair-wise offset projections between levels, keyed as (source, destination) (e.g. (:char, :word)).\nextras ExtraT Optional user payload carried alongside the core data.\n\nTypical workflow\n\nbund = preprocess_corpus(files; strip_html_tags=true)\n\n# inspect vocabulary\nword_vocab = bund.levels[:word].vocabulary\nprintln(\"vocabulary size: \", length(word_vocab.id_to_token_strings))\n\n# project a sentence span back to character offsets\ncm = bund.alignments[(:char, :sentence)]\nfirst_sentence_char_span = cm.alignment[1] : cm.alignment[2]-1\n\nThe bundle is immutable; to add additional levels or extras create a fresh instance (helper functions add_level!, with_extras, etc. are provided by the package).\n\n\n\n\n\n","category":"type"},{"location":"api/#KeemenaPreprocessing.PreprocessBundle-Tuple{Dict{Symbol, <:LevelBundle}}","page":"API Reference","title":"KeemenaPreprocessing.PreprocessBundle","text":"PreprocessBundle(levels; metadata = PipelineMetadata(),\n                      alignments = Dict{Tuple{Symbol,Symbol},CrossMap}(),\n                      extras = nothing) -> PreprocessBundle\n\nOuter constructor that validates and assembles the individual artefacts generated by KeemenaPreprocessing into a single PreprocessBundle.\n\nRequired argument\n\nlevels::Dict{Symbol,<:LevelBundle} - at least one segmentation level (keyed by level name such as :word or :char).\n\nOptional keyword arguments\n\nkeyword default purpose\nmetadata PipelineMetadata() Configuration & schema header.\nalignments empty Dict Maps (source,destination) -> CrossMap.\nextras nothing User-supplied payload propagated unchanged.\n\nRuntime checks\n\nNon-empty levels.\nFor each (lvl, lb) in levels run validate_offsets(lb.corpus, lvl) to ensure internal offset consistency.\nFor every supplied alignment (src,dst) → cm:\nboth src and dst must exist in levels;\nlength(cm.alignment) == length(levels[src].corpus.token_ids);\ncm.source_level      == src;\ncm.destination_level == dst.\n\nAny violation throws an informative ArgumentError.\n\nReturns\n\nA fully-validated PreprocessBundle{typeof(extras)} containing: Dict(levels), metadata, Dict(alignments), and extras.\n\nExample\n\nword_bundle = LevelBundle(word_corpus, word_vocab)\nchar_bundle = LevelBundle(char_corpus, char_vocab)\n\nbund = PreprocessBundle(Dict(:word=>word_bundle, :char=>char_bundle);\n                        alignments = Dict((:char,:word)=>char2word_map))\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.PreprocessBundle-Tuple{}","page":"API Reference","title":"KeemenaPreprocessing.PreprocessBundle","text":"PreprocessBundle(; metadata = PipelineMetadata(), extras = nothing) -> PreprocessBundle\n\nConvenience constructor that produces an empty PreprocessBundle:\n\nlevels     = Dict{Symbol,LevelBundle}()  \nalignments = Dict{Tuple{Symbol,Symbol},CrossMap}()  \nmetadata   = metadata (defaults to PipelineMetadata())  \nextras     = extras   (defaults to nothing)\n\nUseful when you want to build a bundle incrementally—for example, loading individual levels from disk or generating them in separate jobs: while still attaching a common metadata header or arbitrary user payload.\n\nbund = PreprocessBundle()                      # blank skeleton\nbund = merge(bund, load_word_level(\"word.jld\"))  # pseudo-code for adding data\n\nThe returned object's type parameter is inferred from extras so that any payload, including complex structs, can be stored without further boilerplate.\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.PreprocessConfiguration-Tuple{}","page":"API Reference","title":"KeemenaPreprocessing.PreprocessConfiguration","text":"PreprocessConfiguration(; kwargs...) -> PreprocessConfiguration\n\nCreate a fully-specified preprocessing configuration.\n\nAll keyword arguments are optional; sensible defaults are provided so that cfg = PreprocessConfiguration() already yields a working pipeline.  Options are grouped below by the stage they affect.\n\nCleaning stage toggles\n\nkeyword default purpose\nlowercase true Convert letters to lower-case.\nstrip_accents true Remove combining accent marks.\nremove_control_characters true Drop Unicode Cc/Cf code-points.\nremove_punctuation true Strip punctuation & symbol characters.\nnormalise_whitespace true Collapse consecutive whitespace.\nremove_zero_width_chars true Remove zero-width joiners, etc.\npreserve_newlines true Keep explicit line breaks.\ncollapse_spaces true Collapse runs of spaces/tabs.\ntrim_edges true Strip leading/trailing whitespace.\n\nURL, e-mail & numbers\n\nkeyword default purpose\nreplace_urls true Replace URLs with url_sentinel.\nreplace_emails true Replace e-mails with mail_sentinel.\nkeep_url_scheme false Preserve http:// / https:// prefix.\nurl_sentinel \"<URL>\" Token inserted for each URL.\nmail_sentinel \"<EMAIL>\" Token inserted for each e-mail.\nreplace_numbers false Replace numbers with number_sentinel.\nnumber_sentinel \"<NUM>\" Token used when replacing numbers.\nkeep_number_decimal false Preserve decimal part.\nkeep_number_sign false Preserve ± sign.\nkeep_number_commas false Preserve thousands separators.\n\nMark-up & HTML\n\nkeyword default purpose\nstrip_markdown false Remove Markdown formatting.\npreserve_md_code true Keep fenced/inline code while stripping.\nstrip_html_tags false Remove HTML/XML tags.\nhtml_entity_decode true Decode &amp;, &quot;, etc.\n\nEmoji & Unicode\n\nkeyword default purpose\nemoji_handling :keep :keep, :remove, or :sentinel.\nemoji_sentinel \"<EMOJI>\" Used when emoji_handling == :sentinel.\nsqueeze_repeat_chars false Limit repeated character runs.\nmax_char_run 3 Maximum run length when squeezing.\nmap_confusables false Map visually-confusable chars.\nunicode_normalisation_form :none :NFC, :NFD, :NFKC, :NFKD, or :none.\nmap_unicode_punctuation false Replace Unicode punctuation with ASCII.\n\nTokenisation\n\nkeyword default purpose\ntokenizer_name :whitespace One of TOKENIZERS or a callable.\npreserve_empty_tokens false Keep zero-length tokens.\n\nVocabulary construction\n\nkeyword default purpose\nminimum_token_frequency 1 Discard rarer tokens / map to <UNK>.\nspecial_tokens Dict(:unk=>\"<UNK>\", :pad=>\"<PAD>\") Role ⇒ literal mapping.\n\nOffset recording\n\nkeyword default purpose\nrecord_byte_offsets false Record byte-level spans.\nrecord_character_offsets false Record Unicode-char offsets.\nrecord_word_offsets true Record word offsets.\nrecord_sentence_offsets true Record sentence offsets.\nrecord_paragraph_offsets false Record paragraph offsets (forces preserve_newlines = true).\nrecord_document_offsets true Record document offsets.\n\nReturns\n\nA fully-initialised PreprocessConfiguration instance.  Invalid combinations raise AssertionError (e.g. unsupported tokenizer) and certain settings emit warnings when they imply other flags (e.g. paragraph offsets -> preserve_newlines).\n\nSee also: TOKENIZERS and byte_cfg for a pre-canned byte-level configuration.\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.Vocabulary","page":"API Reference","title":"KeemenaPreprocessing.Vocabulary","text":"Vocabulary\n\nImmutable lookup table produced by build_vocabulary that maps between integer token-ids and the string literals that appear in a corpus.\n\nFields\n\nid_to_token_strings::Vector{String}   Position i holds the canonical surface form of token-id i (vocab.id_to_token_strings[id] → \"word\").\ntoken_to_id_map::Dict{String,Int}   Fast reverse mapping from token string to its integer id (vocab.token_to_id_map[\"word\"] → id).   Look-ups fall back to the <UNK> id when the string is absent.\ntoken_frequencies::Vector{Int}   Corpus counts aligned with id_to_token_strings (token_frequencies[id] gives the raw frequency of that token).\nspecial_tokens::Dict{Symbol,Int}   Set of reserved ids for sentinel symbols such as :unk, :pad, :bos, :eos, …   Keys are roles (Symbol); values are the corresponding integer ids.\n\nUsage example\n\nvocab = build_vocabulary(tokens; minimum_token_frequency = 3)\n\n@info \"UNK id:    \" vocab.special_tokens[:unk]\n@info \"«hello» id:\" vocab.token_to_id_map[\"hello\"]\n@info \"id → token:\" vocab.id_to_token_strings[42]\n\n\n\n\n\n","category":"type"},{"location":"api/#KeemenaPreprocessing.add_level!-Tuple{PreprocessBundle, Symbol, LevelBundle}","page":"API Reference","title":"KeemenaPreprocessing.add_level!","text":"add_level!(bundle, level, lb) -> PreprocessBundle\n\nMutating helper that inserts a new LevelBundle lb into bundle.levels under key level.  The routine:\n\nGuards against duplicates - throws an error if level already exists.  \nValidates the offsets inside lb.corpus for consistency with the supplied level via validate_offsets.  \nStores the bundle and returns the same bundle instance so the call can be chained.\n\nbe aware that, add_level! modifies its first argument in place; if you require     an immutable bundle keep a copy before calling\n\nArguments\n\nname type description\nbundle PreprocessBundle Target bundle to extend.\nlevel Symbol Identifier for the new segmentation level (e.g. :char, :word).\nlb LevelBundle Data + vocabulary for that level.\n\nReturns\n\nThe same bundle, now containing level => lb.\n\nErrors\n\nArgumentError if a level with the same name already exists.\nPropagates any error raised by validate_offsets when lb.corpus is inconsistent.\n\nExample\n\nchar_bundle = LevelBundle(char_corp, char_vocab)\nadd_level!(bund, :character, char_bundle)\n\n@assert has_level(bund, :character)\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.byte_cfg-Tuple{}","page":"API Reference","title":"KeemenaPreprocessing.byte_cfg","text":"byte_cfg(; kwargs...) -> PreprocessConfiguration\n\nShorthand constructor that returns a PreprocessConfiguration pre-configured for byte-level tokenisation.\n\nThe wrapper fixes the following fields\n\ntokenizer_name = :byte\nrecord_byte_offsets      = true\nrecord_character_offsets = false\nrecord_word_offsets      = false\n\nwhile forwarding every other keyword argument to PreprocessConfiguration. Use it when building byte-level language-model corpora but still needing the full flexibility to tweak cleaning, vocabulary, or segmentation options:\n\ncfg = byte_cfg(strip_html_tags = true,\n               minimum_token_frequency = 5)\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.get_corpus-Tuple{PreprocessBundle, Symbol}","page":"API Reference","title":"KeemenaPreprocessing.get_corpus","text":"get_corpus(bundle, level) -> Corpus\n\nRetrieve the Corpus object for segmentation level level from a PreprocessBundle.\n\nThis is equivalent to get_level(bundle, level).corpus and is provided as a convenience helper when you only need the sequence of token-ids and offset tables rather than the whole LevelBundle.\n\nArguments\n\nbundle::PreprocessBundle - bundle produced by preprocess_corpus.\nlevel::Symbol - level identifier such as :byte, :word, :sentence, ...\n\nReturns\n\nThe Corpus stored in the requested level.\n\nErrors\n\nThrows an ArgumentError if the level is not present in bundle (see get_level for details).\n\nExample\n\nword_corp = get_corpus(bund, :word)\n\n# iterate over sentences\nsent_offs = word_corp.sentence_offsets\nfor i in 1:length(sent_offs)-1\n    rng = sent_offs[i] : sent_offs[i+1]-1\n    println(view(word_corp.token_ids, rng))\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.get_level-Tuple{PreprocessBundle, Symbol}","page":"API Reference","title":"KeemenaPreprocessing.get_level","text":"get_level(bundle, level) → LevelBundle\n\nFetch the LevelBundle associated with segmentation level level from a PreprocessBundle.\n\nArguments\n\nbundle::PreprocessBundle — bundle returned by preprocess_corpus.\nlevel::Symbol — identifier such as :byte, :word, :sentence, ...\n\nReturns\n\nThe requested LevelBundle.\n\nErrors\n\nThrows an ArgumentError when the level is absent, listing all available levels to aid debugging.\n\nExample\n\nword_bundle = get_level(bund, :word)\nprintln(\"vocabulary size: \", length(word_bundle.vocabulary.id_to_token_strings))\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.get_token_ids-Tuple{PreprocessBundle, Symbol}","page":"API Reference","title":"KeemenaPreprocessing.get_token_ids","text":"get_token_ids(bundle, level) -> Vector{Int}\n\nReturn the vector of token-ids for segmentation level level contained in a PreprocessBundle.\n\nIdentical to   get_corpus(bundle, level).token_ids,   but provided as a convenience helper when you only need the raw id sequence and not the full Corpus object.\n\nArguments\n\nbundle::PreprocessBundle - bundle produced by preprocess_corpus.\nlevel::Symbol - segmentation level identifier (e.g. :byte, :word).\n\nReturns\n\nA Vector{Int} whose length equals the number of tokens at that level.\n\nErrors\n\nThrows an ArgumentError if the requested level is absent (see get_level for details).\n\nExample\n\nword_ids = get_token_ids(bund, :word)\nprintln(\"first ten ids: \", word_ids[1:10])\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.get_vocabulary-Tuple{PreprocessBundle, Symbol}","page":"API Reference","title":"KeemenaPreprocessing.get_vocabulary","text":"get_vocabulary(bundle, level) -> Vocabulary\n\nReturn the Vocabulary associated with segmentation level level (eg :byte, :word, :sentence) from a given PreprocessBundle\n\nEffectively a shorthand for   get_level(bundle, level).vocabulary\n\nArguments\n\nbundle::PreprocessBundle - Bundle produced by preprocess_corpus\nlevel::Symbol — Level identifier whose vocabulary you need\n\nReturns\n\nThe Vocabulary stored for level\n\nErrors\n\nRaises an ArgumentError if level is not present in bundle (see get_level for details)\n\nExample\n\nvocab = get_vocabulary(bund, :word)\nprintln(\"Top-10 tokens: \", vocab.id_to_token_strings[1:10])\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.has_level-Tuple{PreprocessBundle, Symbol}","page":"API Reference","title":"KeemenaPreprocessing.has_level","text":"has_level(bundle, level) -> Bool\n\nReturn true if the given PreprocessBundle contains a LevelBundle for the segmentation level level (e.g. :byte, :word, :sentence); otherwise return false.\n\nArguments\n\nbundle::PreprocessBundle — bundle to inspect.\nlevel::Symbol            — level identifier to look for.\n\nExample\n\njulia> has_level(bund, :word)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.preprocess_corpus-Tuple{Any, PreprocessConfiguration}","page":"API Reference","title":"KeemenaPreprocessing.preprocess_corpus","text":"preprocess_corpus(sources, cfg; save_to = nothing) - PreprocessBundle\n\nVariant of preprocess_corpus that accepts an already constructed PreprocessConfiguration and therefore bypasses all keyword aliasing and default-override logic.\n\nUse this when you have prepared a configuration object up-front (e.g. loaded from disk, shared across jobs, or customised in a function) and want to run the pipeline with those exact settings.\n\nArguments\n\nname type description\nsources AbstractString, Vector{<:AbstractString}, iterable One or more file paths, URLs, directories (ignored), or in-memory text strings.\ncfg PreprocessConfiguration Fully-specified configuration controlling every cleaning/tokenisation option.\nsave_to String or nothing (default) If non-nothing, the resulting bundle is serialised (e.g. via JLD2) to the given file path and returned; otherwise nothing is written.\n\nPipeline (unchanged)\n\nLoad raw sources.\nClean text based on cfg flags.\nTokenise & segment; record requested offsets.\nBuild vocabulary obeying minimum_token_frequency, special_tokens, ...\nPack everything into a PreprocessBundle.  Optionally persist.\n\nReturns\n\nA PreprocessBundle populated with corpora, vocabularies, alignments, metadata, and (by default) empty extras.\n\nExample\n\ncfg  = PreprocessConfiguration(strip_markdown = true,\n                               tokenizer_name  = :unicode)\n\nbund = preprocess_corpus([\"doc1.txt\", \"doc2.txt\"], cfg;\n                         save_to = \"unicode_bundle.jld2\")\n\nnote: If you do not have a configuration object yet, call the keyword-only version instead:       preprocess_corpus(sources; kwargs...)      which will create a default configuration and apply any overrides you provide.\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.preprocess_corpus-Tuple{Any}","page":"API Reference","title":"KeemenaPreprocessing.preprocess_corpus","text":"preprocess_corpus(sources; save_to = nothing,\n                              config = nothing,\n                              kwargs...) -> PreprocessBundle\n\nEnd-to-end convenience wrapper that loads raw texts, cleans them, tokenises, builds a vocabulary, records offsets, and packs the result into a PreprocessBundle.\n\nThe routine can be invoked in two mutually-exclusive ways:\n\nExplicit configuration - supply your own PreprocessConfiguration through the config= keyword.\nAd-hoc keyword overrides - omit config and pass any subset of the configuration keywords directly (e.g. lowercase = false, tokenizer_name = :unicode).   Internally a fresh PreprocessConfiguration(; kwargs...) is created from those overrides plus the documented defaults, so calling preprocess_corpus(sources) with no keywords at all runs the pipeline using the default settings.\n\nnote: Passing both config= and per-field keywords is an error because     it would lead to ambiguous intent.\n\nArguments\n\nname type description\nsources AbstractString, Vector{<:AbstractString}, or iterable Either one or more file paths/URLs that will be read, directories (silently skipped), or in-memory strings treated as raw text.\nsave_to String or nothing (default) If a path is given the resulting bundle is serialised (JLD2) to disk and returned; otherwise nothing is written.\nconfig PreprocessConfiguration or nothing Pre-constructed configuration object.  When nothing (default), a new one is built from kwargs....\nkwargs... see PreprocessConfiguration Per-field overrides that populate a fresh configuration when config is nothing.\n\nPipeline stages\n\nLoading - files/URLs are fetched; directory entries are ignored.\nCleaning - controlled by the configuration's cleaning toggles.\nTokenisation & segmentation - produces token ids and offset tables.\nVocabulary building - applies minimum_token_frequency and inserts special tokens.\nPackaging - returns a PreprocessBundle; if save_to was given, the same bundle is persisted to that path.\n\nReturns\n\nA fully-populated PreprocessBundle.\n\nExamples\n\n# 1. Quick start with defaults\nbund = preprocess_corpus(\"corpus.txt\")\n\n# 2. Fine-grained control via keyword overrides\nbund = preprocess_corpus([\"doc1.txt\", \"doc2.txt\"];\n                         strip_html_tags = true,\n                         tokenizer_name  = :unicode,\n                         minimum_token_frequency = 3)\n\n# 3. Supply a hand-crafted configuration object\ncfg  = PreprocessConfiguration(strip_markdown = true,\n                               record_sentence_offsets = false)\nbund = preprocess_corpus(\"input/\", config = cfg, save_to = \"bundle.jld2\")\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.preprocess_corpus_streaming-Tuple{Any}","page":"API Reference","title":"KeemenaPreprocessing.preprocess_corpus_streaming","text":"preprocess_corpus_streaming(srcs;\n                            cfg           = PreprocessConfiguration(),\n                            vocab         = nothing,\n                            chunk_tokens  = DEFAULT_CHUNK_TOKENS) -> Channel{PreprocessBundle}\n\nLow-memory, two-pass variant of preprocess_corpus that yields a stream of PreprocessBundles via a Channel.   Each bundle covers ≈ chunk_tokens worth of tokens, letting you pipeline huge corpora through training code without ever loading the whole dataset into RAM.\n\nWorkflow\n\nVocabulary pass (optional)   If vocab === nothing, the function first computes global token-frequency counts in a constant-memory scan (_streaming_counts) and builds a vocabulary with build_vocabulary(freqs; cfg).   If you already possess a fixed vocabulary (e.g. for fine-tuning), supply it through the vocab keyword to skip this pass.\nChunking iterator   A background task produced by doc_chunk_iterator groups raw source documents into slices whose estimated size does not exceed chunk_tokens.\nPer-chunk pipeline   For every chunk the following steps mirror the standard pipeline:\nclean_documents\ntokenize_and_segment\nassemble_bundle\nbuild_ensure_alignments!\nThe resulting bundle is put! onto the channel.\n\nArguments\n\nname type description\nsrcs iterable of AbstractString File paths, URLs, or raw texts.\ncfg PreprocessConfiguration Cleaning/tokenisation settings (default: fresh object).\nvocab Vocabulary or nothing Pre-existing vocabulary; when nothing it is inferred in pass 1.\nchunk_tokens Int Soft cap on tokens per chunk (default = DEFAULT_CHUNK_TOKENS).\n\nReturns\n\nA channel of type Channel{PreprocessBundle}.   Consume it with foreach, for bundle in ch, or take!(ch).\n\nch = preprocess_corpus_streaming(\"large_corpus/*\";\n                                 cfg = PreprocessConfiguration(strip_html_tags=true),\n                                 chunk_tokens = 250_000)\n\nfor bund in ch                      # streaming training loop\n    update_model!(bund)             # user-defined function\nend\n\nnote: The channel is unbuffered (Inf capacity) so each bundle is produced only     when the consumer is ready, minimising peak memory consumption.\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.preprocess_corpus_streaming_chunks-Tuple{Any}","page":"API Reference","title":"KeemenaPreprocessing.preprocess_corpus_streaming_chunks","text":"preprocess_corpus_streaming_chunks(srcs; kwargs...) -> 4Vector{PreprocessBundle}\n\nRun the streaming pipeline once, eagerly consume the channel, and return a Vector whose i-th entry is the PreprocessBundle covering chunk i.\n\nIdentical keyword interface to preprocess_corpus_streaming; all arguments are forwarded unchanged.\n\nUse when you want chunked artefacts (e.g. sharding a massive corpus across GPUs) but prefer a materialised vector instead of an explicit Channel.\n\nbundles = preprocess_corpus_streaming_chunks(\"wiki_xml/*\";\n                                   chunk_tokens = 250_000,\n                                   strip_html_tags = true)\n@info \"produced $(length(bundles)) bundles\"\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.preprocess_corpus_streaming_full-Tuple{Any}","page":"API Reference","title":"KeemenaPreprocessing.preprocess_corpus_streaming_full","text":"preprocesscorpusstreaming_full(srcs; kwargs...) -> PreprocessBundle\n\nRun the streaming pipeline, merge every chunk on the fly, and return one single PreprocessBundle that spans the entire corpus.\n\nAll keyword arguments are forwarded to preprocesscorpusstreaming. Throws when chunks were built with incompatible vocabularies\n\nbund = preprocess_corpus_streaming_full([\"en.txt\", \"de.txt\"];\n                              minimum_token_frequency = 5)\nprintln(\"corpus length: \", length(get_token_ids(bund, :word)))\n\n\n\n\n\n","category":"method"},{"location":"api/#KeemenaPreprocessing.with_extras-Tuple{PreprocessBundle, Any}","page":"API Reference","title":"KeemenaPreprocessing.with_extras","text":"with_extras(original, new_extras) -> PreprocessBundle\n\nCreate a shallow copy of original where only the extras field is replaced by new_extras.  All other components (levels, metadata, alignments) are cloned by reference, so the operation is cheap and the returned bundle remains consistent with the source.\n\nUseful when you have performed post-processing (e.g. dimensionality reduction, cluster assignments, per-document labels) and want to attach the results without mutating the original bundle in place.\n\nArguments\n\nname type description\noriginal PreprocessBundle Bundle produced by preprocess_corpus.\nnew_extras Any Arbitrary payload to store under bundle.extras.\n\nReturns\n\nA new PreprocessBundle{typeof(new_extras)} identical to original except that extras == new_extras.\n\nExample\n\nlabels = collect(kmeans(doc_embeddings, 50).assignments)\nlabeled = with_extras(bund, labels)\n\n@assert labeled.levels === bund.levels         # same reference\n@assert labeled.extras === labels              # updated payload\n\n\n\n\n\n","category":"method"},{"location":"guides/configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"PreprocessConfiguration is a single struct that controls every stage of the preprocessing pipeline:","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"Stage What it governs\nCleaning Unicode normalisation, punctuation stripping, URL / e-mail / number replacement, Markdown & HTML removal, emoji handling, repeated-character squeezing, confusable mapping …\nTokenisation Choice of built-in or custom tokenizer; whether to keep zero-length tokens.\nVocabulary Minimum token frequency cutoff; special-token mapping.\nSegmentation Which offset levels (byte, char, word, sentence, paragraph, document) should be recorded.","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"A brand-new configuration with all defaults is just:","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"using KeemenaPreprocessing\ncfg = PreprocessConfiguration()     # ready to go","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"guides/configuration/#Keyword-reference","page":"Configuration","title":"Keyword reference","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"Below is an exhaustive table of every keyword accepted by PreprocessConfiguration(; kwargs...).   Arguments are grouped by stage; omit any keyword to keep its default.","category":"page"},{"location":"guides/configuration/#Cleaning-toggles","page":"Configuration","title":"Cleaning toggles","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"keyword default description\nlowercase true Convert letters to lower-case.\nstrip_accents true Remove combining accent marks.\nremove_control_characters true Drop Unicode Cc / Cf code-points.\nremove_punctuation true Strip punctuation & symbol characters.\nnormalise_whitespace true Collapse consecutive whitespace to a single space.\nremove_zero_width_chars true Remove zero-width joiners, etc.\npreserve_newlines true Keep explicit \\n; needed for paragraph offsets.\ncollapse_spaces true Collapse runs of spaces / tabs.\ntrim_edges true Strip leading / trailing whitespace.","category":"page"},{"location":"guides/configuration/#URL,-e-mail-and-number-replacement","page":"Configuration","title":"URL, e-mail & number replacement","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"keyword default purpose\nreplace_urls true Replace URLs with url_sentinel.\nreplace_emails true Replace e-mails with mail_sentinel.\nkeep_url_scheme false Preserve http:// / https:// prefix.\nurl_sentinel \"<URL>\" Literal token replacing each URL.\nmail_sentinel \"<EMAIL>\" Literal token replacing each e-mail.\nreplace_numbers false Replace numbers with number_sentinel.\nnumber_sentinel \"<NUM>\" Token used when replacing numbers.\nkeep_number_decimal false Preserve decimal part.\nkeep_number_sign false Preserve + / - sign.\nkeep_number_commas false Preserve thousands separators.","category":"page"},{"location":"guides/configuration/#Mark-up-and-HTML","page":"Configuration","title":"Mark-up & HTML","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"keyword default description\nstrip_markdown false Remove Markdown formatting.\npreserve_md_code true Keep fenced / inline code while stripping.\nstrip_html_tags false Remove HTML / XML tags.\nhtml_entity_decode true Decode &amp;, &quot;, …","category":"page"},{"location":"guides/configuration/#Emoji-and-Unicode-normalisation","page":"Configuration","title":"Emoji & Unicode normalisation","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"keyword default description\nemoji_handling :keep :keep, :remove, or :sentinel.\nemoji_sentinel \"<EMOJI>\" Used when emoji_handling == :sentinel.\nsqueeze_repeat_chars false Limit repeated characters (sooooo → sooo).\nmax_char_run 3 Max run length when squeezing.\nmap_confusables false Map visually confusable Unicode chars to ASCII.\nunicode_normalisation_form :none :NFC, :NFD, :NFKC, :NFKD, or :none.\nmap_unicode_punctuation false Replace fancy punctuation with ASCII analogues.","category":"page"},{"location":"guides/configuration/#Tokenisation","page":"Configuration","title":"Tokenisation","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"keyword default description\ntokenizer_name :whitespace One of TOKENIZERS or a custom f(::String) callable.\npreserve_empty_tokens false Keep zero-length tokens if the tokenizer returns them.","category":"page"},{"location":"guides/configuration/#Vocabulary-construction","page":"Configuration","title":"Vocabulary construction","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"keyword default purpose\nminimum_token_frequency 1 Tokens below this frequency map to <UNK>.\nspecial_tokens Dict(:unk=>\"<UNK>\", :pad=>\"<PAD>\") Role ⇒ literal token mapping.","category":"page"},{"location":"guides/configuration/#Offset-recording","page":"Configuration","title":"Offset recording","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"keyword default description\nrecord_byte_offsets false Record byte-level spans.\nrecord_character_offsets false Record Unicode-character offsets.\nrecord_word_offsets true Record word offsets.\nrecord_sentence_offsets true Record sentence offsets.\nrecord_paragraph_offsets false Record paragraph offsets (forces preserve_newlines = true).\nrecord_document_offsets true Record document offsets.","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"guides/configuration/#Built-in-tokenizers","page":"Configuration","title":"Built-in tokenizers","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"const TOKENIZERS = (:whitespace, :unicode, :byte, :char)","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"name behaviour typical use\n:whitespace split(text) on Unicode whitespace Most word-level corpora.\n:unicode Iterate grapheme clusters (eachgrapheme) Languages with complex scripts, emoji, accents.\n:byte Raw UTF-8 bytes (UInt8) Byte-level LLM pre-training.\n:char Individual UTF-8 code-units Character-level models / diagnostics.","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"You may pass any callable that returns a Vector{<:AbstractString}:","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"mytok(text) = split(lowercase(text), r\"[ \\-]+\")\n\ncfg = PreprocessConfiguration(tokenizer_name = mytok)","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"guides/configuration/#Helper:-byte_cfg","page":"Configuration","title":"Helper: byte_cfg","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"cfg = byte_cfg(strip_html_tags = true,\n               minimum_token_frequency = 5)","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"byte_cfg is a thin wrapper that pre-sets   tokenizer_name = :byte, record_byte_offsets = true, and disables char / word offsets.   All other keywords are forwarded unchanged.","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"guides/configuration/#Examples","page":"Configuration","title":"Examples","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"### Language-agnostic, emoji-masked corpus","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"cfg = PreprocessConfiguration(\n          strip_html_tags         = true,\n          emoji_handling          = :sentinel,\n          minimum_token_frequency = 3)\n\nbund = preprocess_corpus(\"multilang_news/*\"; config = cfg)","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"### Paragraph-level offsets for document classification","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"cfg = PreprocessConfiguration(\n          record_paragraph_offsets = true,   # auto-enables preserve_newlines\n          tokenizer_name            = :unicode)\n\nbund = preprocess_corpus(\"reports/*.txt\"; config = cfg)","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"### Extreme byte-level pre-training","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"cfg = byte_cfg(\n          squeeze_repeat_chars    = true,\n          max_char_run            = 5,\n          minimum_token_frequency = 10)\n\nbund = preprocess_corpus(\"c4_dump/*\"; config = cfg, save_to = \"byte_bundle.jld2\")","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"guides/configuration/#Notes-and-assertions","page":"Configuration","title":"Notes & assertions","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"minimum_token_frequency must be ≥ 1.  \ntokenizer_name must be one of TOKENIZERS or a callable.  \nEnabling record_paragraph_offsets = true automatically sets preserve_newlines = true (with a warning).  \nemoji_handling must be :keep, :remove, or :sentinel.  \nunicode_normalisation_form must be :none, :NFC, :NFD, :NFKC, or :NFKD.","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"Invalid combinations raise AssertionError, so mistakes fail fast during configuration construction rather than deep inside the pipeline.","category":"page"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"guides/configuration/#Return-value","page":"Configuration","title":"Return value","text":"","category":"section"},{"location":"guides/configuration/","page":"Configuration","title":"Configuration","text":"PreprocessConfiguration(… ) always yields a fully-populated, immutable struct ready to be stored in bundle metadata or reused across jobs.","category":"page"},{"location":"guides/streaming/#Streaming-Pre-processing-API","page":"Streaming Pipeline","title":"Streaming Pre-processing API","text":"","category":"section"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"KeemenaPreprocessing streaming pipeline lets you work with corpora that do not fit in RAM.   Internally it runs in two passes:","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"Vocabulary pass - a constant-memory scan to count tokens and build the Vocabulary (skipped when you pass vocab=).\nChunk pass - documents are grouped into slices of ≈ chunk_tokens and each slice becomes a PreprocessBundle.","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"Three helpers expose the same keywords as preprocess_corpus but differ in how you consume the results:","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"Helper Returns Best when …\npreprocess_corpus_streaming Channel{PreprocessBundle} You want back-pressure inside a training loop.\npreprocess_corpus_streaming_chunks Vector{PreprocessBundle} You prefer materialised chunks (e.g. GPU sharding).\npreprocess_corpus_streaming_full PreprocessBundle You need one big bundle but can't load the raw corpus at once.","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"","category":"page"},{"location":"guides/streaming/#1-Stream-through-a-Channel-(more-manual)","page":"Streaming Pipeline","title":"1 - Stream through a Channel (more manual)","text":"","category":"section"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"cfg = PreprocessConfiguration(tokenizer_name=:unicode,\n                              record_document_offsets=true)\n\nch = preprocess_corpus_streaming(\"data/*\"; cfg, chunk_tokens = 250_000)\n\nfor bund in ch                      # JIT production, O(1 chunk) RAM\n    update_model!(bund)             # your training step\nend","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"The channel is unbuffered (Inf capacity) - a new bundle is produced only when the consumer is ready.","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"","category":"page"},{"location":"guides/streaming/#2-·-Collect-chunks-into-a-vector-(more-automatic)","page":"Streaming Pipeline","title":"2 · Collect chunks into a vector (more automatic)","text":"","category":"section"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"bundles = preprocess_corpus_streaming_chunks(\"wiki_xml/*\";\n                                             cfg          = cfg,\n                                             chunk_tokens = 250_000)\n\n@info \"produced $(length(bundles)) bundles\"\nshuffle!(bundles)      # easy data-parallel sharding","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"Internally identical to collect(preprocess_corpus_streaming(...)).","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"","category":"page"},{"location":"guides/streaming/#3-·-Merge-chunks-on-the-fly-(automatic)","page":"Streaming Pipeline","title":"3 · Merge chunks on the fly (automatic)","text":"","category":"section"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"bundle = preprocess_corpus_streaming_full([\"en.txt\", \"de.txt\"];\n                                        cfg          = cfg,\n                                        chunk_tokens = 50_000,\n                                        minimum_token_frequency = 5)\n\n@info \"corpus length: $(length(get_token_ids(bundle, :word)))\"","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"Merges each chunk into an accumulator in constant memory.  \nVerifies all chunks share the same Vocabulary and cfg.  \nCalls build_ensure_alignments! to regenerate byte/char <-> word maps.","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"","category":"page"},{"location":"guides/streaming/#Choosing-chunk_tokens","page":"Streaming Pipeline","title":"Choosing chunk_tokens","text":"","category":"section"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"Corpus size Suggested chunk_tokens\n< 1 M words 10 000 - 20 000\n1-10 M words 20 000 - 100 000\n> 10 M words 100 000 + (benchmark)","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"Aim for 'fits comfortably on GPU' rather than 'largest possible.'","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"","category":"page"},{"location":"guides/streaming/#Sentinel-conventions","page":"Streaming Pipeline","title":"Sentinel conventions","text":"","category":"section"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"Offset vectors follow one of two patterns:","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"0 ... N - leading sentinel 0, trailing N\n1 ... N+1 - leading 1, trailing N+1","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"The merge helper recognises both.  For any offset vector it guarantees:","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"issorted(offsets) == true\nfirst(offsets) in (0, 1)\nlast(offsets)  >= n_tokens","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"","category":"page"},{"location":"guides/streaming/#Common-pitfalls","page":"Streaming Pipeline","title":"Common pitfalls","text":"","category":"section"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"Pitfall Remedy\nProducer stalls because channel is not consumed Use foreach or collect-based helpers.\nMixing configs or vocabularies then concatenating by hand Use preprocess_corpus_streaming_full, which throws on mismatch.\nChunk size too small (< 2 k tokens) Causes task-switch overhead; start at 10 k.\nAdding new levels with different sentinel rules Extend the merge the helper sentinel logic and add a test.","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"","category":"page"},{"location":"guides/streaming/#Helper-signatures-(for-reference)","page":"Streaming Pipeline","title":"Helper signatures (for reference)","text":"","category":"section"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"preprocess_corpus_streaming_chunks(srcs; kwargs...) -> Vector{PreprocessBundle}\n\npreprocess_corpus_streaming_full(srcs; kwargs...)  -> PreprocessBundle\n\npreprocess_corpus_streaming(srcs;\n    cfg           = PreprocessConfiguration(),\n    vocab         = nothing,\n    chunk_tokens  = DEFAULT_CHUNK_TOKENS\n) -> Channel{PreprocessBundle}","category":"page"},{"location":"guides/streaming/","page":"Streaming Pipeline","title":"Streaming Pipeline","text":"All keyword arguments are forwarded unchanged.   See PreprocessConfiguration for the full list.","category":"page"},{"location":"guides/offsets/#Offset-Vectors-and-Segmentation-Levels","page":"Offsets","title":"Offset Vectors & Segmentation Levels","text":"","category":"section"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"Keemena stores every corpus as a flat vector of token-ids plus one or more   offset vectors that mark the boundaries of higher-level units   (bytes -> characters -> words -> sentences -> paragraphs -> documents).","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"Understanding these vectors lets you","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"slice substrings for data augmentation,\nproject annotations between levels,\nand validate or extend the pipeline.","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"## Anatomy of an offset vector","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"offsets = [s0, s1, ..., sn]        # length = n_tokens   or   n_tokens + 1\n                                   # 1-based indices into corpus.token_ids","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"entry meaning\ns0 leading sentinel - 0 or 1 (optional)\ns1 inclusive start index of token i\nsn trailing sentinel - n_tokens or n_tokens+1 (optional)","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"start = offsets[i]\nstop  = offsets[i+1] - 1           # inclusive index range of token i","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"validate_offsets guaranteesissorted(offsets, lt = <)  \nfirst(offsets) in (0, 1) (if a leading sentinel exists)  \nlast(offsets) >= n_tokens  \nlength(offsets) >= n_tokens  When sentinel recording is disabled for a level the vector length equals n_tokens and the sentinel checks are skipped.","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"","category":"page"},{"location":"guides/offsets/#Sentinel-conventions-by-level","page":"Offsets","title":"Sentinel conventions by level","text":"","category":"section"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"Level symbol Default sentinel style Typical unit\n:byte [0 ... n] UTF-8 byte\n:character [0 ...… n] Unicode scalar\n:word [1 ... n+1] whitespace / tokenizer word\n:sentence [1 ... n+1] heuristic sentence\n:paragraph [1 ... n+1] blank-line span\n:document [1 ... n+1] source document","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"Trailing sentinels may be either the last token index n_tokens (inclusive style) or n_tokens + 1 (exclusive style).   The streaming merge helper accepts both and deduplicates them, so every offset vector in a merged bundle ends with exactly one sentinel.","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"## Mapping symbols -> vectors","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"Keemena keeps an internal lookup table","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"KeemenaPreprocessing.LEVEL_TO_OFFSETS_FIELD","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"that translates a segmentation symbol to the corresponding field name inside Corpus:","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"Symbol Corpus field\n:byte :byte_offsets\n:character :character_offsets\n:word :word_offsets\n:sentence :sentence_offsets\n:paragraph :paragraph_offsets\n:document :document_offsets","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"field = KeemenaPreprocessing.LEVEL_TO_OFFSETS_FIELD[:sentence]\nsent  = getfield(corpus, field)          # Vector{Int} or `nothing`","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"Advanced only   The table is accessible but not exported; ordinary users do not modify it directly.  To register a new level use   add_level!(bundle, :my_level, lb) which both validates offsets and updates the lookup table behind the scenes.","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"## Cross-level alignment","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"When two levels share the same span (e.g. bytes & characters) Keemena derives a CrossMap:","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"cm = alignment_byte_to_word(byte_corp, word_corp)\ndst_word_idx = cm.alignment[src_byte_idx]     # O(1) lookup","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"build_ensure_alignments! automatically adds three canonical maps to every bundle:","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"(:byte      , :character)\n(:byte      , :word)\n(:character , :word)","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"## Practical snippets","category":"page"},{"location":"guides/offsets/#Extract-raw-text-for-the-42-nd-word","page":"Offsets","title":"Extract raw text for the 42-nd word","text":"","category":"section"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"wc   = bundle.levels[:word].corpus\nspan = wc.word_offsets[42] : wc.word_offsets[43] - 1\nraw  = String(codeunits(bundle.extras.raw_text)[span])","category":"page"},{"location":"guides/offsets/#Sentence-lengths-(words-per-sentence)","page":"Offsets","title":"Sentence lengths (words per sentence)","text":"","category":"section"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"wc  = bundle.levels[:word].corpus\nsnt = wc.sentence_offsets                       # requires record_sentence_offsets=true\nlengths = diff(snt)                             # Vector{Int}","category":"page"},{"location":"guides/offsets/#Shuffle-paragraph-spans","page":"Offsets","title":"Shuffle paragraph spans","text":"","category":"section"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"pc = bundle.levels[:paragraph].corpus\nspans = [pc.paragraph_offsets[i] : pc.paragraph_offsets[i+1] - 1\n         for i in 1:length(pc.paragraph_offsets)-1]\nshuffle!(spans)","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"## Add a custom level (advanced workflow)","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"#  build monotone offset vector (leading 1, trailing n+1)\nmy_offs = [1, 8, 15, 22, n_tokens + 1]\n\n#  clone an existing corpus and attach new offsets\ncorpus = deepcopy(bundle.levels[:word].corpus)\nsetfield!(corpus, :my_offsets, my_offs)\n\n#  wrap & insert; add_level! validates and registers lookup entry\nmy_lvl = LevelBundle(corpus,\n                     bundle.levels[:word].vocabulary)\nadd_level!(bundle, :my_level, my_lvl)","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"","category":"page"},{"location":"guides/offsets/#Troubleshooting","page":"Offsets","title":"Troubleshooting","text":"","category":"section"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"Symptom Likely cause Fix\n'offsets define k segments but corpus has n tokens' duplicate or missing trailing sentinel regenerate offsets or let streaming merge rebuild them\n'Offsets must be strictly increasing' offsets edited out of order sort or recreate\nAlignment length mismatch corpora built from different cleaned text re-process both levels in the same pipeline","category":"page"},{"location":"guides/offsets/","page":"Offsets","title":"Offsets","text":"Following these rules keeps all built-in helpers—slicing utilities, streaming merge, alignment builders—working seamlessly and lets your custom levels interoperate with the rest of KeemenaPreprocessing.","category":"page"},{"location":"guides/alignment/#Alignment-helpers","page":"Alignment","title":"Alignment helpers","text":"","category":"section"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Many downstream tasks need to project annotations or errors between tokenisation levels : eg 'Which word does byte 123 belong to?'. KeemenaPreprocessing encapsulates these look-ups in a small record:","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"struct CrossMap\n    source_level      :: Symbol   # :byte, :character, ...\n    destination_level :: Symbol   # :word, ...\n    alignment         :: Vector{Int}   # 1-based destination index per source\nend","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"For every source token index i you obtain the corresponding destination token as map.alignment[i].","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"","category":"page"},{"location":"guides/alignment/#Low-level-constructors","page":"Alignment","title":"Low-level constructors","text":"","category":"section"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Function Produces Preconditions\nalignment_byte_to_word(byte_c, word_c) :byte -> :word each corpus has byte_offsets / word_offsets and both share the same span.\nalignment_char_to_word(char_c, word_c) :character -> :word ditto, but via character offsets.\nalignment_byte_to_char(byte_c, char_c) :byte -> :character ditto.","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Example:","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"b2w = alignment_byte_to_word(byte_corpus, word_corpus)\nword_of_42nd_byte = b2w.alignment[42]","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Errors:","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"ArgumentError if the required offset vectors are missing or\nthe two corpora cover different spans (byte_offsets[end] != word_offsets[end]).","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"","category":"page"},{"location":"guides/alignment/#Bundle-level-helpers","page":"Alignment","title":"Bundle-level helpers","text":"","category":"section"},{"location":"guides/alignment/#_ensure_lower_levels!(bundle)","page":"Alignment","title":"_ensure_lower_levels!(bundle)","text":"","category":"section"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"bundle = _ensure_lower_levels!(bundle)","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"If the bundle has a :word level and that word corpus already stores character_offsets and/or byte_offsets, this function:","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"synthesises dummy :character / :byte corpora   token-ids are filled with <UNK>,\nadds them as levels (vocabulary = 1-token dummy),\nleaves existing levels untouched,\nreturns the same bundle (mutated in place).","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Idempotent: calling it again is a no-op.","category":"page"},{"location":"guides/alignment/#build_alignments!(bundle;-pairs-[(:byte,:word),-...])","page":"Alignment","title":"build_alignments!(bundle; pairs = [(:byte,:word), ...])","text":"","category":"section"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Creates the requested CrossMaps iff the corresponding levels exist and the map is not already present.","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"build_alignments!(bundle)          # default three maps\nbuild_alignments!(bundle; pairs=[(:character,:word)])","category":"page"},{"location":"guides/alignment/#build_ensure_alignments!(bundle)","page":"Alignment","title":"build_ensure_alignments!(bundle)","text":"","category":"section"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"One-stop convenience:","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"build_ensure_alignments!(bundle)","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Calls _ensure_lower_levels!,  \nCalls build_alignments! with the default trio,  \nReturns the bundle (mutated).","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"","category":"page"},{"location":"guides/alignment/#Typical-workflow","page":"Alignment","title":"Typical workflow","text":"","category":"section"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"bund = preprocess_corpus(\"alice.txt\", config = cfg)\n\n# guarantee byte/char levels + alignments\nbuild_ensure_alignments!(bund)\n\nword_of_first_byte = bund.alignments[(:byte,:word)].alignment[1]","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Inside the high-level pipelines:","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"preprocess_corpus creates all three levels + alignments by default.\npreprocess_corpus_streaming / _chunks / _full call build_ensure_alignments! for every chunk (and again after merging), so the resulting bundles are always fully aligned.","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"","category":"page"},{"location":"guides/alignment/#Sentinel-assumptions","page":"Alignment","title":"Sentinel assumptions","text":"","category":"section"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Offset vectors must satisfy:","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"issorted(offsets) == true\nfirst(offsets) in (0,1)         # leading sentinel\nlast(offsets)  >=  n_tokens     # trailing sentinel","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"alignment_* functions interpret every index in offsets[i] : offsets[i+1]-1 as belonging to token i.","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"","category":"page"},{"location":"guides/alignment/#Troubleshooting","page":"Alignment","title":"Troubleshooting","text":"","category":"section"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Symptom Likely cause Fix\nArgumentError: byte and word corpora cover different span Word corpus was trimmed during cleaning but byte corpus was not. Re-run the pipeline; byte and word corpora must originate from the same cleaned text.\nKeyError when accessing bundle.alignments[(src,dst)] Map not built (levels missing or function not called). Call build_ensure_alignments!(bundle) or ensure both levels exist before build_alignments!.\nDummy vocabularies contain only <UNK> Expected - lower levels are placeholders used solely for alignment. ","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"","category":"page"},{"location":"guides/alignment/#Helper-signatures-(for-reference)","page":"Alignment","title":"Helper signatures (for reference)","text":"","category":"section"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"alignment_byte_to_word(byte_c::Corpus, word_c::Corpus)       -> CrossMap\nalignment_char_to_word(char_c::Corpus, word_c::Corpus)       -> CrossMap\nalignment_byte_to_char(byte_c::Corpus, char_c::Corpus)       -> CrossMap\n\n_ensure_lower_levels!(bundle::PreprocessBundle)              -> PreprocessBundle\nbuild_alignments!(bundle::PreprocessBundle; pairs = ...)     -> PreprocessBundle\nbuild_ensure_alignments!(bundle::PreprocessBundle)           -> PreprocessBundle","category":"page"},{"location":"guides/alignment/","page":"Alignment","title":"Alignment","text":"Once you have called build_ensure_alignments!, every bundle is guaranteed to contain the canonical :byte -> :character -> :word chain.","category":"page"},{"location":"#KeemenaPreprocessing.jl-:smile:","page":"Home","title":"KeemenaPreprocessing.jl   :smile:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clean → Tokenise/Segment → Bundle","category":"page"},{"location":"","page":"Home","title":"Home","text":"using KeemenaPreprocessing\ncfg    = PreprocessConfiguration()\nbundle = preprocess_corpus(\"data/alice.txt\"; config = cfg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"👉 See the Guides for worked examples  \n👉 Full API in the reference","category":"page"},{"location":"guides/quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"The preprocess_corpus wrapper lets you go from raw text -> cleaned, tokenised, aligned, and fully-packaged PreprocessBundle in one line.   Its only required argument is sources (strings, file paths, URLs, or any iterable that mixes them). Everything else is optional.","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"You pass… What happens\nNo config= and no keywords A fresh PreprocessConfiguration is created with all documented defaults.\nKeyword overrides but no config= A fresh configuration is built from the defaults plus your overrides.\nconfig = cfg object That exact configuration is used; keyword overrides are forbidden (ambiguity).","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"## Minimal 'hello bundle' (all defaults)","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"using KeemenaPreprocessing\n\nbund = preprocess_corpus(\"my_corpus.txt\") #one-liner\n@show bund.vocab_size","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"## Single in-memory string","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"raw = \"\"\"\n      It was a dark stormy night,\n      And we see Sherlock Holmes.\n      \"\"\"\n\nbund = preprocess_corpus(raw) # treats `raw` as a document","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"## Multiple strings (small ad-hoc corpus)","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"docs = [\n    \"Mary had a little lamb.\",\n    \"Humpty-Dumpty sat on a wall.\",\n    \"\"\"\n    Roses are red,\n    violets are blue\n    \"\"\"\n]\n\nbund = preprocess_corpus(docs;\n                         tokenizer_name = :whitespace,\n                         minimum_token_frequency = 2)","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/#Multiple-**file-paths**","page":"Quick Start","title":"Multiple file paths","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"sources = [\"data/alice.txt\",\n           \"data/time_machine.txt\",\n           \"/var/corpora/news_2024.txt\"]\n\nbund = preprocess_corpus(sources; lowercase = false)","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"Directories in sources are silently skipped; mixing paths and raw strings is fine.","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/#Remote-URLs","page":"Quick Start","title":"Remote URLs","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"urls = [\n    \"https://www.gutenberg.org/files/11/11-0.txt\",   # Alice\n    \"https://www.gutenberg.org/files/35/35-0.txt\"    # Time Machine\n]\n\nbund = preprocess_corpus(urls;\n                         tokenizer_name = :unicode,\n                         record_sentence_offsets = true)","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/#Zero-configuration-**byte-level**-tokenisation","page":"Quick Start","title":"Zero-configuration byte-level tokenisation","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg  = byte_cfg()                 # shorthand helper\nbund = preprocess_corpus(\"binary_corpus.bin\", cfg)","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/#Saving-and-loading-bundles","page":"Quick Start","title":"Saving and loading bundles","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg   = PreprocessConfiguration(minimum_token_frequency = 5)\nbund1 = preprocess_corpus(\"my_corpus.txt\";\n                          config  = cfg,\n                          save_to = \"corpus.jld2\")\n\nbund2 = load_preprocess_bundle(\"corpus.jld2\")","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/#Alignments-and-CrossMap","page":"Quick Start","title":"Alignments and CrossMap","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"Every time you call preprocess_corpus (streaming or not) the helper   build_ensure_alignments! adds deterministic mappings between all recorded segmentation levels:","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"Offset arrays eg bundle.levels[:word].corpus.sentence_offsets.\nCrossMap : sparse look-up tables linking byte -> char -> word -> sentence indices","category":"page"},{"location":"guides/quickstart/#a-Inspecting-offsets","page":"Quick Start","title":"a Inspecting offsets","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"wc = get_corpus(bund, :word)     # word-level Corpus\n@show wc.sentence_offsets[1:10]  # sentinel-terminated, always sorted","category":"page"},{"location":"guides/quickstart/#Byte-word-mapping-for-a-single-token","page":"Quick Start","title":"Byte -> word mapping for a single token","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"btw = bund.levels[:word].cross_map        # `CrossMap` object\nbyte_ix = 12345\nword_ix = btw(byte_ix)    # constant-time lookup","category":"page"},{"location":"guides/quickstart/#Convenience-helpers","page":"Quick Start","title":"Convenience helpers","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"word_ix = alignment_byte_to_word(bund, byte_ix)\nchar_ix = alignment_byte_to_char(bund, byte_ix)","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"These helpers are thin wrappers over CrossMap, but keep your code independent of the underlying representation.","category":"page"},{"location":"guides/quickstart/#Working-with-*multiple*-segmentation-levels","page":"Quick Start","title":"Working with multiple segmentation levels","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"The pipeline can record byte, character, word, sentence, paragraph, and document offsets simultaneously.   Just enable the flags you need in the configuration:","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"using KeemenaPreprocessing\n\ncfg = PreprocessConfiguration(\n          tokenizer_name            = :unicode,    # word-ish tokens\n          record_byte_offsets       = true,\n          record_character_offsets  = true,\n          record_word_offsets       = true,\n          record_sentence_offsets   = true,\n          record_paragraph_offsets  = true,\n          record_document_offsets   = true)\n\nbund = preprocess_corpus(\"demo.txt\"; config = cfg)\n\nbyte_corp = get_corpus(bund, :byte)        # each token is UInt8\nchar_corp = get_corpus(bund, :char)        # Unicode code-points\nword_corp = get_corpus(bund, :word)        # words / graphemes\nsent_offs = word_corp.sentence_offsets     # sentinel-terminated\npara_offs = word_corp.paragraph_offsets\ndoc_offs  = word_corp.document_offsets\n\n@show (byte_corp.token_ids[1:10],\n       char_corp.token_ids[1:10],\n       word_corp.token_ids[1:10])","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"By default every offset array is sorted and sentinel-terminated (last == n_tokens + 1), so it is safe to searchsortedlast or binary-search into them.","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"## Supplying a custom tokenizer function","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"Any callable f(::AbstractString) -> Vector{String} can replace the built-ins.   Below we split on whitespace and the dash \"‐\" character:","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"using KeemenaPreprocessing\n\nfunction dash_whitespace_tok(text::AbstractString)\n    return split(text, r\"[ \\t\\n\\r\\-]+\", keepempty = false)\nend\n\ncfg = PreprocessConfiguration(\n          tokenizer_name           = dash_whitespace_tok,    # <- callable\n          minimum_token_frequency  = 2,\n          record_word_offsets      = true)\n\ndocs  = [\"state-of-the-art models excel\",   # note the dashes\n         \"art-of-war is timeless\"]\n\nbund   = preprocess_corpus(docs; config = cfg)\n\n# Inspect the custom tokenisation\nwc = get_corpus(bund, :word)\n@show map(tid -> wc.vocabulary.string(tid), wc.token_ids)","category":"page"},{"location":"guides/quickstart/#Tips-for-custom-tokenisers","page":"Quick Start","title":"Tips for custom tokenisers","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"Requirement Guideline\nReturn type Vector{<:AbstractString} (no UInt8).\nNo trimming If you want empty tokens preserved, call with preserve_empty_tokens = true.\nOffsets Only :byte and :char levels need special handling; CrossMap takes care of higher levels automatically.","category":"page"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"guides/quickstart/#pitfalls","page":"Quick Start","title":"pitfalls","text":"","category":"section"},{"location":"guides/quickstart/","page":"Quick Start","title":"Quick Start","text":"Pitfall Symptom Fix\nPassing config= and keyword overrides ErrorException: Pass either config= or per-field keywords, not both. Pick one method; never both.\nrecord_paragraph_offsets = true but preserve_newlines = false Warning and paragraphs not recorded. Enable preserve_newlines (done automatically with a warning).\nUnsupported tokenizer_name symbol AssertionError Check TOKENIZERS or supply a callable.","category":"page"}]
}
